<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

    var methods = new[]
    {
        "SingleQueue", 
        "DoubleQueue", 
        "Binary",  
        "Text",
    };

    Func<string, string> GetChannelFields = method =>
    {
        if (methods[0] == method)
        {
            return @"
        private readonly Channel<SentMessage> _sentMessageQueue;
        private readonly ChannelReader<SentMessage> _sentMessageQueueReader;
        private readonly ChannelWriter<SentMessage> _sentMessageQueueWriter;";
        }

        if (methods[1] == method)
        {
            return @"
        private readonly Channel<ArraySegment<byte>> _sentBinaryMessageQueue;
        private readonly ChannelReader<ArraySegment<byte>> _sentBinaryMessageQueueReader;
        private readonly ChannelWriter<ArraySegment<byte>> _sentBinaryMessageQueueWriter;
            
        private readonly Channel<ArraySegment<byte>> _sentTextMessageQueue;
        private readonly ChannelReader<ArraySegment<byte>> _sentTextMessageQueueReader;
        private readonly ChannelWriter<ArraySegment<byte>> _sentTextMessageQueueWriter;";
        }

        if (methods[2] == method || methods[3] == method)
        {
            return @"
        private readonly Channel<ArraySegment<byte>> _sentMessageQueue;
        private readonly ChannelReader<ArraySegment<byte>> _sentMessageQueueReader;
        private readonly ChannelWriter<ArraySegment<byte>> _sentMessageQueueWriter;";
        }

        return "";
    };


    Func<string, string> InitializeChannel = method =>
    {
        if (methods[0] == method)
        {
            return @"
            _sentMessageQueue = sentMessageQueue ?? Channel.CreateUnbounded<SentMessage>(new UnboundedChannelOptions { SingleReader = true, SingleWriter = false });
            _sentMessageQueueReader = _sentMessageQueue.Reader;
            _sentMessageQueueWriter = _sentMessageQueue.Writer;";
        }

        if (methods[1] == method)
        {
            return @"
            _sentBinaryMessageQueue = sentBinaryMessageQueue ?? Channel.CreateUnbounded<ArraySegment<byte>>(new UnboundedChannelOptions { SingleReader = true, SingleWriter = false });;
            _sentBinaryMessageQueueReader = _sentBinaryMessageQueue.Reader;
            _sentBinaryMessageQueueWriter = _sentBinaryMessageQueue.Writer;
            
            _sentTextMessageQueue = sentTextMessageQueue ?? Channel.CreateUnbounded<ArraySegment<byte>>(new UnboundedChannelOptions { SingleReader = true, SingleWriter = false });;
            _sentTextMessageQueueReader = _sentTextMessageQueue.Reader;
            _sentTextMessageQueueWriter = _sentTextMessageQueue.Writer;";
        }

        if (methods[2] == method || methods[3] == method)
        {
            return @"
            _sentMessageQueue = sentMessageQueue ?? Channel.CreateUnbounded<ArraySegment<byte>>(new UnboundedChannelOptions { SingleReader = true, SingleWriter = false });
            _sentMessageQueueReader = _sentMessageQueue.Reader;
            _sentMessageQueueWriter = _sentMessageQueue.Writer;";
        }

        return "";
    };


    Func<string, string> SetChannelConstructorWithDefault = method =>
    {
        if (methods[0] == method)
        {
            return @"Channel<SentMessage> sentMessageQueue = null";
        }

        if (methods[1] == method)
        {
            return @"Channel<ArraySegment<byte>> sentBinaryMessageQueue = null, Channel<ArraySegment<byte>> sentTextMessageQueue = null";
        }

        if (methods[2] == method || methods[3] == method)
        {
            return @"Channel<ArraySegment<byte>> sentMessageQueue = null";
        }

        return "";
    };

    Func<string, string> SetChannelConstructor = method =>
    {
        if (methods[0] == method)
        {
            return @"Channel<SentMessage> sentMessageQueue";
        }

        if (methods[1] == method)
        {
            return @"Channel<ArraySegment<byte>> sentBinaryMessageQueue, Channel<ArraySegment<byte>> sentTextMessageQueue";
        }

        if (methods[2] == method || methods[3] == method)
        {
            return @"Channel<ArraySegment<byte>> sentMessageQueue";
        }

        return "";
    };

    Func<string, string> SetFallbackConstructor = method =>
    {
        if (methods[1] == method)
        {
            return "sentBinaryMessageQueue, sentTextMessageQueue";
        }

        return @"sentMessageQueue";
    };


    Func<string, string> SetWriterComplete = method =>
    {
        if (methods[1] == method)
        {
            return @"
                _sentBinaryMessageQueueWriter.Complete();
                _sentTextMessageQueueWriter.Complete();";
        }

        return "_sentMessageQueueWriter.Complete();";
    };




#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using RxWebSocket.Exceptions;
using RxWebSocket.Threading;
using RxWebSocket.Validations;
using RxWebSocket.Logging;

#if NETSTANDARD2_1 || NETSTANDARD2_0 || NETCOREAPP3_1
using System.Reactive.Subjects;
using System.Reactive.Linq;
#else
using UniRx;
#endif
 
namespace RxWebSocket
{
<# foreach(var method in methods) { #>

   public partial class <#= method #>WebSocketClient : IWebSocketClient
    {
        #region Member variable with state.
        private readonly ILogger _logger;

        private readonly MemoryPool _memoryPool;

        private readonly Func<Uri, CancellationToken, Task<WebSocket>> _connectionFactory;

        private readonly AsyncLock _openLocker = new AsyncLock();
        private readonly AsyncLock _sendLocker = new AsyncLock();
        private readonly AsyncLock _closeLocker = new AsyncLock();

        private readonly Subject<byte[]> _binaryMessageReceivedSubject = new Subject<byte[]>();
        private readonly Subject<string> _textMessageReceivedSubject = new Subject<string>();

        private readonly Subject<CloseMessage> _closeMessageReceivedSubject = new Subject<CloseMessage>();
        private readonly Subject<WebSocketExceptionDetail> _exceptionSubject = new Subject<WebSocketExceptionDetail>();

        private readonly CancellationTokenSource _cancellationCurrentJobs = new CancellationTokenSource();
        private readonly CancellationTokenSource _cancellationAllJobs = new CancellationTokenSource();

        <#= GetChannelFields(method)#>

        private WebSocket _socket;

        public Uri Url { get; }

        /// <summary>
        /// For logging purpose.
        /// </summary>
        public string Name { get; set; } = "CLIENT";

        public bool IsDisposed { get; private set; }

        public Encoding MessageEncoding { get; set; } = Encoding.UTF8;

        public DateTime LastReceivedTime { get; private set; } = DateTime.UtcNow;

        public Task WaitUntilClose { get; private set; }
        #endregion

        /// <param name="url">Target websocket url (wss://)</param>
        /// <param name="clientFactory">Optional factory for native ClientWebSocket, use it whenever you need some custom features (proxy, settings, etc)</param>
        public <#= method #>WebSocketClient(Uri url, <#= SetChannelConstructorWithDefault(method)#>, Func<ClientWebSocket> clientFactory = null)
            : this(url, ReceivingMemoryConfig.Default, <#= SetFallbackConstructor(method) #>, null, MakeConnectionFactory(clientFactory))
        {
        }

        /// <param name="url">Target websocket url (wss://)</param>
        /// <param name="logger"></param>
        /// <param name="clientFactory">Optional factory for native ClientWebSocket, use it whenever you need some custom features (proxy, settings, etc)</param>
        public <#= method #>WebSocketClient(Uri url, ILogger logger, <#= SetChannelConstructorWithDefault(method)#>, Func<ClientWebSocket> clientFactory = null)
            : this(url, ReceivingMemoryConfig.Default, <#= SetFallbackConstructor(method) #>, logger, MakeConnectionFactory(clientFactory))
        {
        }

        /// <param name="url">Target websocket url (wss://)</param>
        /// <param name="receivingMemoryConfig"></param>
        /// <param name="logger"></param>
        /// <param name="clientFactory">Optional factory for native ClientWebSocket, use it whenever you need some custom features (proxy, settings, etc)</param>
        public <#= method #>WebSocketClient(Uri url, ReceivingMemoryConfig receivingMemoryConfig, ILogger logger = null, <#= SetChannelConstructorWithDefault(method)#>, Func<ClientWebSocket> clientFactory = null)
            : this(url, receivingMemoryConfig, <#= SetFallbackConstructor(method) #>, logger, MakeConnectionFactory(clientFactory))
        {
        }

        public <#= method #>WebSocketClient(
            Uri url, 
            ReceivingMemoryConfig receivingMemoryConfig, 
            <#= SetChannelConstructor(method)#>, 
            ILogger logger, 
            Func<Uri, CancellationToken, Task<WebSocket>> connectionFactory)
        {
            if (!ValidationUtils.ValidateInput(url))
            {
                throw new WebSocketBadInputException($"url is null. Please correct it.");
            }

            Url = url;

            _logger = logger;
            _memoryPool = new MemoryPool(receivingMemoryConfig.InitialMemorySize, receivingMemoryConfig.MarginSize, logger);

            _connectionFactory = connectionFactory ?? (async (uri, token) =>
            {
                var client = new ClientWebSocket
                {
                    Options = { KeepAliveInterval = new TimeSpan(0, 0, 0, 10) }
                };
                await client.ConnectAsync(uri, token).ConfigureAwait(false);
                return client;
            });

            <#= InitializeChannel(method) #>
        }

        /// <summary>
        /// </summary>
        /// <param name="logger"></param>
        /// <param name="connectedSocket">Already connected socket.</param>
        public <#= method #>WebSocketClient(WebSocket connectedSocket, ILogger logger = null, <#= SetChannelConstructorWithDefault(method)#>)
        {
            Url = null;

            _logger = logger;
            _connectionFactory = (uri, token) => Task.FromResult(connectedSocket);

            _memoryPool = new MemoryPool(ReceivingMemoryConfig.Default.InitialMemorySize, ReceivingMemoryConfig.Default.MarginSize, logger);

            <#= InitializeChannel(method) #>
        }

        /// <summary>
        /// </summary>
        /// <param name="receivingMemoryConfig"></param>
        /// <param name="logger"></param>
        /// <param name="connectedSocket">Already connected socket.</param>
        public <#= method #>WebSocketClient(WebSocket connectedSocket, ReceivingMemoryConfig receivingMemoryConfig, ILogger logger = null, <#= SetChannelConstructorWithDefault(method)#>)
        {
            Url = null;

            _logger = logger;
            _connectionFactory = (uri, token) => Task.FromResult(connectedSocket);

            _memoryPool = new MemoryPool(receivingMemoryConfig.InitialMemorySize, receivingMemoryConfig.MarginSize, logger);

            <#= InitializeChannel(method) #>
        }

        public WebSocket NativeSocket => _socket;

        public bool IsOpen => _socket != null && _socket.State == WebSocketState.Open;
        public bool IsClosed => _socket != null && _socket.State == WebSocketState.Closed;

        public WebSocketState WebSocketState => _socket?.State ?? WebSocketState.None;

        public IObservable<ResponseMessage> MessageReceived => _binaryMessageReceivedSubject
            .Select(ResponseMessage.BinaryMessage)
            .Merge(_textMessageReceivedSubject.Select(ResponseMessage.TextMessage));

        public IObservable<byte[]> BinaryMessageReceived => _binaryMessageReceivedSubject.AsObservable();

        public IObservable<string> TextMessageReceived => _textMessageReceivedSubject.AsObservable();

        public IObservable<CloseMessage> CloseMessageReceived => _closeMessageReceivedSubject.AsObservable();

        public IObservable<WebSocketExceptionDetail> ExceptionHappened => _exceptionSubject.AsObservable();

        /// <summary>
        /// Start connect and listening to the websocket stream on the background thread
        /// </summary>
        public async Task ConnectAndStartListening()
        {
            using (await _openLocker.LockAsync().ConfigureAwait(false))
            {
                if (IsOpen)
                {
                    _logger?.Warn(FormatLogMessage("WebSocketClient is already open."));
                    return;
                }

                if (IsDisposed)
                {
                    _logger?.Error(FormatLogMessage("WebSocketClient is already disposed."));
                    throw new ObjectDisposedException("WebSocketClient is already disposed.");
                }

                var connectionTask = ConnectAndStartListeningInternal(Url, _cancellationCurrentJobs.Token);

                StartBackgroundThreadForSendingMessage();

                await connectionTask.ConfigureAwait(false);
            }
        }

        private async Task ConnectAndStartListeningInternal(Uri uri, CancellationToken token)
        {
            try
            {
                if (_socket == null)
                {
                    _logger?.Log(FormatLogMessage("Connecting..."));
                }
                _socket = await _connectionFactory(uri, token).ConfigureAwait(false);
                _logger?.Log(FormatLogMessage("Start Listening..."));
                WaitUntilClose = Listen(_socket, token);
                LastReceivedTime = DateTime.UtcNow;
            }
            catch (Exception e)
            {
                _logger?.Error(e, FormatLogMessage($"Exception while connecting. detail: {e.Message}"));
                throw;
            }
        }

        public void Dispose()
        {
            if (IsDisposed)
            {
                return;
            }

            IsDisposed = true;
            _logger?.Log(FormatLogMessage("Disposing..."));

            try
            {
                _cancellationAllJobs.Cancel();
                _cancellationCurrentJobs.Cancel();

                if (!IsClosed)
                {
                    _socket?.Abort();
                }

                _socket?.Dispose();

                _cancellationAllJobs.Dispose();
                _cancellationCurrentJobs.Dispose();

                <#= SetWriterComplete(method) #>

                _binaryMessageReceivedSubject.Dispose();
                _textMessageReceivedSubject.Dispose();
                _closeMessageReceivedSubject.Dispose();
                _exceptionSubject.Dispose();
            }
            catch (Exception e)
            {
                _logger?.Error(e, FormatLogMessage($"Failed to dispose client, error: {e.Message}"));
                throw;
            }
        }

        /// <summary>
        /// Close WebSocket.
        /// This function is equivalent to CloseAsync(status, statusDescription, true)
        /// </summary>
        /// <param name="status"></param>
        /// <param name="statusDescription"></param>
        public Task CloseAsync(WebSocketCloseStatus status, string statusDescription)
        {
            return CloseAsync(status, statusDescription, true);
        }

        /// <summary>
        /// Close WebSocket
        /// </summary>
        /// <param name="status"></param>
        /// <param name="statusDescription"></param>
        /// <param name="dispose"></param>
        public async Task CloseAsync(WebSocketCloseStatus status, string statusDescription, bool dispose)
        {
            // prevent sending multiple disconnect requests.
            using (await _closeLocker.LockAsync().ConfigureAwait(false))
            {
                if (IsClosed)
                {
                    return;
                }

                if (_socket == null ||
                    _socket.State == WebSocketState.Aborted ||
                    _socket.State == WebSocketState.None)
                {
                    _logger?.Warn(FormatLogMessage($"Called CloseAsync, but websocket state is {(_socket == null ? "null" : _socket.State.ToString())}. It is not correct."));
                    return;
                }

                try
                {
                    // await until the connection closed.
                    await _socket.CloseAsync(status, statusDescription, _cancellationCurrentJobs.Token).ConfigureAwait(false);

                    if (dispose)
                    {
                        this.Dispose();
                    }
                }
                catch (Exception e)
                {
                    _logger?.Error(e, FormatLogMessage($"Error while closing client, message: '{e.Message}'"));
                    throw;
                }
            }
        }

        private static Func<Uri, CancellationToken, Task<WebSocket>> MakeConnectionFactory(Func<ClientWebSocket> clientFactory)
        {
            if (clientFactory == null)
            {
                return null;
            }

            return (async (uri, token) =>
            {
                var client = clientFactory();
                await client.ConnectAsync(uri, token).ConfigureAwait(false);
                return client;
            });
        }

        private async Task Listen(WebSocket client, CancellationToken token)
        {
            try
            {
                do
                {
                    _memoryPool.Offset = 0;
                    var memorySegment = _memoryPool.SliceFromOffset();

                    WebSocketReceiveResult result;
                    do
                    {
                        result = await client.ReceiveAsync(memorySegment, token).ConfigureAwait(false);

                        if (result.MessageType != WebSocketMessageType.Close)
                        {
                            _memoryPool.Offset += result.Count;
                            memorySegment = _memoryPool.SliceFromOffset();
                        }
                    }
                    while (!result.EndOfMessage);

                    LastReceivedTime = DateTime.UtcNow;

                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var receivedText = MessageEncoding.GetString(_memoryPool.ToArray());
                        _logger?.Log(FormatLogMessage($"Received: Type Text: {receivedText}"));
                        _textMessageReceivedSubject.OnNext(receivedText);
                    }
                    else if (result.MessageType == WebSocketMessageType.Binary)
                    {
                        var dstArray = _memoryPool.ToArray();
                        _logger?.Log(FormatLogMessage($"Received: Type Binary, length: {dstArray?.Length}"));
                        _binaryMessageReceivedSubject.OnNext(dstArray);
                    }
                    else if (result.MessageType == WebSocketMessageType.Close)
                    {
                        //close handshake
                        if (result.CloseStatus != null)
                        {
                            _logger?.Log(FormatLogMessage($"Received: Close Message, Status: {result.CloseStatus.Value}, Description: {result.CloseStatusDescription}"));
                            _closeMessageReceivedSubject.OnNext(new CloseMessage(result.CloseStatus.Value, result.CloseStatusDescription));
                            try
                            {
                                await CloseAsync(WebSocketCloseStatus.NormalClosure, $"Response to the close message. Received close status: {result.CloseStatus.Value}", true).ConfigureAwait(false);
                            }
                            catch (Exception e)
                            {
                                _logger?.Error(e, FormatLogMessage($"Close message was received, so trying to close socket, but exception occurred. error: '{e.Message}'"));
                                if (!IsDisposed)
                                {
                                    _exceptionSubject.OnNext(new WebSocketExceptionDetail(e, ErrorType.CloseMessageReceive));
                                }
                            }
                        }
                        return;
                    }
                }
                while (client.State == WebSocketState.Open && !token.IsCancellationRequested);
            }
            catch (TaskCanceledException)
            {
                // task was canceled, ignore
            }
            catch (OperationCanceledException)
            {
                // operation was canceled, ignore
            }
            catch (ObjectDisposedException)
            {
                // client was disposed, ignore
            }
            catch (Exception e)
            {
                _logger?.Error(e, FormatLogMessage($"Error while listening to websocket stream, error: '{e.Message}'"));
                if (!IsDisposed)
                {
                    _exceptionSubject.OnNext(new WebSocketExceptionDetail(e, ErrorType.Listen));
                }
            }
        }

        private string FormatLogMessage(string msg)
        {
            return $"[WEBSOCKET {Name}] {msg}";
        }
    }
<# } #>
}